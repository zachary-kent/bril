### Summary
- Collaborators: @zachary-kent, @rcplane, @Enochen
- We implemented a reference counting garbage collector in the TypeScript implementation of `brili`. Modified [brili](https://github.com/zachary-kent/bril/blob/gc/brili.ts) and [brench](https://github.com/zachary-kent/bril/blob/gc/gc.toml) file.
### Implementation
- We modified the `State` type, extending it with two fields: `rc` and `freeCandidates`:
  - `rc : Map<number, number>` maps base pointers to their reference count
  - `freeCandidates : Set<number>` is a set of memory locations with reference count 0 that have not been freed
  These fields maintain all of the information needed to track the reference count of memory locations
- Then, we implemented `incrementRc`, which increments the reference count of a memory location and removes it from the `freeCandidates` set, if present.
- We also implemented the `freeCandidates` function, which frees every pointer in `freeCandidates`. Freeing these candidates may decrease the reference count of other pointers, which become elgible for freeing if this count drops to 0. We implemented this using a worklist algorithm, where the worklist is initialized to `freeCandidates`. While the worklist is not empty, we pop a pointer `p` from the worklist. We free the pointer `p` and process the process the descendants of `p` in the points-to graph, if there are any. First, we check the type of the data that `p` points to. If this type is not itself a pointer, we continue to the next iteration of the loop, as `p` has no descendants in the points-to graph. Because `p` may have size greater than 1, we have to iterate over every pointer in this array, decrementing their reference count and adding these pointers to the worklist if their reference count drops to 0. This way, we process "cascading" decreases in reference counts.
- We implemented `decrementRc`, which decrements a pointer's reference count and places it in `freeCandidates` if its reference count drops to 0. It does not, however, free the pointer itself.
- We now modified the execution of the interpreter to maintain reference counts. When executing a value operation, we decrement the reference count of the pointer previously stored to its destination (if any), and increment the reference count of the pointer newly stored there (if any). We also implement the same logic for `store` instructions, incrementing the reference count of the pointer previously stored at the target location (if any), and incrementing the reference count of the pointer newly stored there (if any). When executing a function call, we also increment the reference count of all pointer arguments to the callee; when the function returns, we decrement the reference count of any pointers stored as local variables, including the parameters.
### Testing
- Fortunately, `brili` already has built-in functionality for checking memory leaks and illegal frees. Thus, to test our garbage collector, we modified `brili` to treat every `free` as a `nop` and used `brench` to run every benchmark, confirming that we had no memory leaks or illegal fress.
### Difficulties
- There were many corner cases to worry about. We enumerate some of the tricky ones here:
  - Value operations where an identifier is overwritten with the same base pointer it stored previously. If pointers are freed "eagerly," first decrementing the reference count of the pointer can cause it to be freed when its reference count is 1. 
  - Returns from function calls; on returning from a function, we decrement the reference count of all locals, including the returned value, if any. This may cause the reference count of a returned pointer to drop to 0 and it to be freed despite being used by the caller.
- Both of these issues were addressed by processing decrements "lazily" using the above worklist scheme; we free potential candidates only after each instruction is completely excecuted, preventing premature frees.
